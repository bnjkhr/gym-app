import SwiftUI
import Charts
import UserNotifications
import SwiftData
import HealthKit
#if canImport(ActivityKit)
import ActivityKit
#endif

// Import the keyboard dismissal utilities

// MARK: - Performance: Cached DateFormatters

/// Cached DateFormatters to avoid expensive initialization on every render
/// DateFormatter initialization costs ~50ms, cached access costs ~0.001ms
enum DateFormatters {
    /// Long date format: "Montag, 6. Oktober 2025"
    static let germanLong: DateFormatter = {
        let formatter = DateFormatter()
        formatter.locale = Locale(identifier: "de_DE")
        formatter.timeZone = TimeZone.current
        formatter.dateStyle = .long
        formatter.timeStyle = .none
        return formatter
    }()

    /// Medium date format: "6. Okt. 2025"
    static let germanMedium: DateFormatter = {
        let formatter = DateFormatter()
        formatter.locale = Locale(identifier: "de_DE")
        formatter.timeZone = TimeZone.current
        formatter.dateStyle = .medium
        formatter.timeStyle = .none
        return formatter
    }()

    /// Short time format: "14:30"
    static let germanShortTime: DateFormatter = {
        let formatter = DateFormatter()
        formatter.locale = Locale(identifier: "de_DE")
        formatter.timeZone = TimeZone.current
        formatter.dateStyle = .none
        formatter.timeStyle = .short
        return formatter
    }()

    /// Custom format: "EEEEdMMMM" -> "Montag6Oktober"
    static let germanWeekdayDayMonth: DateFormatter = {
        let formatter = DateFormatter()
        formatter.locale = Locale(identifier: "de_DE")
        formatter.timeZone = TimeZone.current
        formatter.setLocalizedDateFormatFromTemplate("EEEEdMMMM")
        return formatter
    }()

    /// Custom format: "MMMMy" -> "Oktober 2025"
    static let germanMonthYear: DateFormatter = {
        let formatter = DateFormatter()
        formatter.locale = Locale(identifier: "de_DE")
        formatter.timeZone = TimeZone.current
        formatter.setLocalizedDateFormatFromTemplate("MMMMy")
        return formatter
    }()

    /// Get very short weekday symbols for German locale: ["Mo", "Di", "Mi", ...]
    static func germanVeryShortWeekdaySymbols() -> [String] {
        let formatter = DateFormatter()
        formatter.locale = Locale(identifier: "de_DE")
        return formatter.veryShortWeekdaySymbols
    }
}

// MARK: - ShareSheet for Workout Sharing

struct ShareSheet: UIViewControllerRepresentable {
    let activityItems: [Any]

    func makeUIViewController(context: Context) -> UIActivityViewController {
        UIActivityViewController(activityItems: activityItems, applicationActivities: nil)
    }

    func updateUIViewController(_ uiViewController: UIActivityViewController, context: Context) {}
}

struct ShareItem: Identifiable {
    let id = UUID()
    let url: URL
}

struct ContentView: View {
    @StateObject private var workoutStore = WorkoutStore()
    @Environment(\.scenePhase) private var scenePhase
    @Environment(\.colorScheme) private var colorScheme
    @Environment(\.modelContext) private var modelContext
    @Environment(\.isInWorkoutDetail) private var isInWorkoutDetail

    // Performance: Pre-warm keyboard to avoid initial delay
    @State private var keyboardPreWarmer: UITextField? = nil

    @Query(sort: [
        SortDescriptor(\WorkoutEntity.date, order: SortOrder.reverse)
    ])
    private var workoutEntities: [WorkoutEntity]

    @State private var selectedTab = 0
    @State private var showingEndWorkoutConfirmation = false

    var body: some View {
        TabView(selection: $selectedTab) {
            // Workouts Tab
            NavigationStack {
                WorkoutsHomeView()
                    .environmentObject(workoutStore)
            }
            .tabItem {
                Image(systemName: "house")
                Text("Home")
            }
            .tag(0)

            // Workouts Tab
            NavigationStack {
                WorkoutsTabView()
                    .environmentObject(workoutStore)
            }
            .tabItem {
                Image(systemName: "dumbbell")
                Text("Workouts")
            }
            .tag(1)

            // Insights Tab
            NavigationStack {
                StatisticsView()
                    .environmentObject(workoutStore)
            }
            .tabItem {
                Image(systemName: "chart.line.uptrend.xyaxis")
                Text("Insights")
            }
            .tag(2)
        }
        .overlay(alignment: .bottom) {
            // ActiveWorkoutBar wird angezeigt wenn ein aktives Workout existiert (aber nicht in WorkoutDetailView)
            if let activeWorkout = workoutStore.activeWorkout, !workoutStore.isShowingWorkoutDetail {
                VStack(spacing: 0) {
                    Spacer()

                    ActiveWorkoutBar(
                        workout: activeWorkout,
                        resumeAction: {
                            // Switch to Home tab and signal to navigate to active workout
                            selectedTab = 0
                            NotificationCenter.default.post(name: .resumeActiveWorkout, object: nil)
                        },
                        endAction: { showingEndWorkoutConfirmation = true }
                    )
                    .environmentObject(workoutStore)
                    .padding(.horizontal, 16)
                    .padding(.bottom, 90) // Platz für die Tab-Bar (ca. 50px TabBar + 40px Spacing)
                    .transition(.move(edge: .bottom).combined(with: .opacity))
                    .animation(.spring(response: 0.35, dampingFraction: 0.8), value: workoutStore.isShowingWorkoutDetail)
                    .animation(.spring(response: 0.35, dampingFraction: 0.8), value: workoutStore.activeWorkout?.id)
                }
                .ignoresSafeArea(.keyboard)
            }
        }
        .animation(.easeInOut(duration: 0.2), value: selectedTab)
        .tint(AppTheme.powerOrange)
        .environment(\.keyboardDismissalEnabled, true)
        .alert("Workout beenden?", isPresented: $showingEndWorkoutConfirmation) {
            Button("Beenden", role: .destructive) {
                endActiveSession()
            }
            Button("Abbrechen", role: .cancel) { }
        } message: {
            Text("Das aktive Workout wird beendet und gelöscht.")
        }
        .onAppear {
            // Set model context in WorkoutStore immediately when view appears
            workoutStore.modelContext = modelContext

            // Initialize AudioManager
            _ = AudioManager.shared

            // Performance: Pre-warm keyboard to avoid initial delay
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                let textField = UITextField()
                textField.becomeFirstResponder()
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                    textField.resignFirstResponder()
                }
                keyboardPreWarmer = textField
            }
        }
        .task {
            NotificationManager.shared.requestAuthorization()
        }
        .onChange(of: scenePhase) { _, newPhase in
            switch newPhase {
            case .active:
                workoutStore.refreshRestFromWallClock()
            default:
                break
            }
        }
        .onOpenURL { url in
            // Handle .gymtracker file import
            if url.pathExtension.lowercased() == "gymtracker" {
                importWorkout(from: url)
                return
            }

            // Handle deep link from Live Activity to jump into the active workout
            guard url.scheme?.lowercased() == "workout" else { return }
            if url.host?.lowercased() == "active" {
                if workoutStore.activeSessionID != nil {
                    // Switch to Home tab first
                    selectedTab = 0
                    // Then signal the WorkoutsHomeView to navigate to active workout
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                        NotificationCenter.default.post(name: .resumeActiveWorkout, object: nil)
                    }
                }
            }
        }
        .onReceive(NotificationCenter.default.publisher(for: .navigateToWorkoutsTab)) { _ in
            selectedTab = 1
            // Mark "explored workouts" as completed when user navigates to Workouts tab
            if !workoutStore.userProfile.hasExploredWorkouts {
                workoutStore.markOnboardingStep(hasExploredWorkouts: true)
            }
        }
    }

    private func resumeActiveWorkout() {
        guard let active = workoutStore.activeWorkout else {
            workoutStore.activeSessionID = nil
            return
        }
        
        // Navigate to the active workout using the WorkoutsHomeView selection
        // This will be handled by the child view's selectedWorkout state
        WorkoutLiveActivityController.shared.start(workoutName: active.name)
    }
    
    private func endActiveSession() {
        workoutStore.stopRest()
        workoutStore.activeSessionID = nil
        WorkoutLiveActivityController.shared.end()
    }

    private func importWorkout(from url: URL) {
        do {
            // JSON-Datei laden
            let shareable = try ShareableWorkout.importFrom(url: url)

            // Übungen aus DB laden
            let descriptor = FetchDescriptor<ExerciseEntity>()
            let exercises = try modelContext.fetch(descriptor)

            // WorkoutEntity erstellen
            let _ = try shareable.toWorkoutEntity(in: modelContext, exerciseEntities: exercises)

            print("✅ Workout '\(shareable.workout.name)' erfolgreich importiert")
        } catch {
            print("❌ Fehler beim Importieren des Workouts: \(error)")
        }
    }
}

private struct WorkoutSelection: Identifiable, Hashable {
    let id: UUID
}

private struct ScrollOffsetPreferenceKey: PreferenceKey {
    static var defaultValue: CGFloat = 0
    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
        value = nextValue()
    }
}

// MARK: - Workouts Tab

struct WorkoutsHomeView: View {
    @EnvironmentObject var workoutStore: WorkoutStore
    @Environment(\.colorScheme) private var colorScheme

    @Environment(\.modelContext) private var modelContext
    @Query(sort: [
        SortDescriptor(\WorkoutEntity.date, order: SortOrder.reverse)
    ])
    private var workoutEntities: [WorkoutEntity]
    
    @Query(sort: [
        SortDescriptor(\WorkoutSessionEntity.date, order: SortOrder.reverse)
    ])
    private var sessionEntities: [WorkoutSessionEntity]

    @State private var showingSettings = false
    @State private var showingProfileEditor = false
    @State private var showingCalendar = false
    @State private var showingLockerNumberInput = false

    @State private var selectedWorkout: WorkoutSelection?
    @State private var editingWorkoutSelection: WorkoutSelection?
    @State private var viewingSession: WorkoutSession?
    @State private var missingTemplateName: String?
    @State private var showingMissingTemplateAlert = false

    // Neu: Zustand für Löschbestätigung
    @State private var workoutToDelete: Workout?
    @State private var shareItem: ShareItem?
    @State private var showingHomeLimitAlert = false

    @State private var headerHidden: Bool = false
    @State private var lastScrollOffset: CGFloat = 0
    @State private var didSetInitialOffset: Bool = false

    // Performance: Cache mapped entities to avoid re-mapping on every render
    @State private var cachedWorkouts: [Workout] = []
    @State private var cachedSessions: [WorkoutSession] = []
    
    private func workoutCategory(for workout: Workout) -> String {
        let exerciseNames = workout.exercises.map { $0.exercise.name.lowercased() }
        
        let machineKeywords = ["maschine", "machine", "lat", "press", "curl", "extension", "row"]
        let freeWeightKeywords = ["hantel", "kurzhantel", "langhantel", "dumbbell", "barbell", "squat", "deadlift", "bench"]
        
        let hasMachine = exerciseNames.contains { name in
            machineKeywords.contains { keyword in name.contains(keyword) }
        }
        
        let hasFreeWeight = exerciseNames.contains { name in
            freeWeightKeywords.contains { keyword in name.contains(keyword) }
        }
        
        if hasMachine && hasFreeWeight {
            return "Mixed"
        } else if hasMachine {
            return "Maschinen"
        } else if hasFreeWeight {
            return "Freie Gewichte"
        } else {
            return "Training"
        }
    }

    private var timeBasedGreeting: String {
        let hour = Calendar.current.component(.hour, from: Date())
        switch hour {
        case 5..<12: return "Guten Morgen"
        case 12..<18: return "Guten Tag"
        case 18..<22: return "Guten Abend"
        default: return "Gute Nacht"
        }
    }

    private var weekStart: Date {
        let calendar = Calendar.current
        return calendar.date(from: calendar.dateComponents([.yearForWeekOfYear, .weekOfYear], from: Date())) ?? Date()
    }

    private var workoutsThisWeek: Int {
        displaySessions.filter { $0.date >= weekStart }.count
    }

    private var minutesThisWeek: Int {
        displaySessions
            .filter { $0.date >= weekStart }
            .compactMap { $0.duration }
            .map { Int($0 / 60) }
            .reduce(0, +)
    }

    private func mapExerciseEntity(_ entity: ExerciseEntity) -> Exercise? {
        // Use safe mapping with context to avoid touching potentially invalidated snapshots
        return Exercise(entity: entity, in: modelContext)
    }

    private func mapWorkoutEntity(_ entity: WorkoutEntity) -> Workout? {
        // Use safe mapping with context to avoid touching potentially invalidated snapshots
        return Workout(entity: entity, in: modelContext)
    }

    // Performance: Use cached values instead of recomputing on every access
    private var displayWorkouts: [Workout] {
        cachedWorkouts
    }

    private var displaySessions: [WorkoutSession] {
        cachedSessions
    }

    private var sortedWorkouts: [Workout] {
        displayWorkouts
    }
    
    private var favoritedWorkouts: [Workout] {
        displayWorkouts.filter { $0.isFavorite }
    }

    // Precomputed helpers to reduce type-checking complexity
    private var highlightSession: WorkoutSession? {
        displaySessions.first
    }

    private var storedRoutines: [Workout] {
        displayWorkouts
    }

    private var mainScrollView: AnyView {
        AnyView(
            ScrollView(showsIndicators: false) {
                LazyVStack(spacing: 0) {
                    headerSection
                        .padding(.bottom, 24)

                    highlightSection(highlightSession: highlightSession)

                    favoriteWorkoutsSection(favoritedWorkouts: favoritedWorkouts)
                        .padding(.top, 24)
                }
                .padding(.horizontal, 20)
                .padding(.top, 8)
                .padding(.bottom, 32)
            }
            .coordinateSpace(name: "workoutsScroll")
            .transaction { tx in
                tx.animation = nil
            }
            .overlay(
                GeometryReader { geo in
                    Color.clear
                        .preference(
                            key: ScrollOffsetPreferenceKey.self,
                            value: geo.frame(in: .named("workoutsScroll")).minY
                        )
                }
            )
        )
    }

    var body: some View {
        rootView
    }

    private func handleScrollOffsetChange(_ newValue: CGFloat) {
        if !didSetInitialOffset {
            lastScrollOffset = newValue
            didSetInitialOffset = true
            return
        }
        let delta = newValue - lastScrollOffset
        if delta < -5 {
            if !headerHidden { headerHidden = true }
        } else if delta > 5 {
            if headerHidden { headerHidden = false }
        }
        lastScrollOffset = newValue
    }

    private var rootView: AnyView {
        let baseView = createBaseView()
        let viewWithToolbars = addToolbars(to: baseView)
        let viewWithSheets = addSheets(to: viewWithToolbars)
        let viewWithNavigationDestinations = addNavigationDestinations(to: viewWithSheets)
        let viewWithAlerts = addAlerts(to: viewWithNavigationDestinations)
        
        return AnyView(viewWithAlerts)
    }
    
    private func createBaseView() -> some View {
        ZStack {
            Color(.systemBackground)
                .ignoresSafeArea()
            
            mainScrollView
        }
        .onPreferenceChange(ScrollOffsetPreferenceKey.self) { newValue in
            handleScrollOffsetChange(newValue)
        }
    }
    
    private func addToolbars(to view: some View) -> some View {
        view
            .toolbar(.hidden, for: .navigationBar)
            .toolbar {
                // no SwiftData toggle toolbar item anymore
            }
    }
    
    private func addSheets(to view: some View) -> some View {
        view
            .sheet(isPresented: $showingProfileEditor) {
                ProfileEditView()
                    .environmentObject(workoutStore)
            }
            .sheet(isPresented: $showingCalendar) {
                CalendarSessionsView()
            }
            .sheet(isPresented: $showingSettings) {
                SettingsView()
                    .environmentObject(workoutStore)
            }
            .fullScreenCover(isPresented: $showingLockerNumberInput) {
                LockerNumberInputView()
                    .environmentObject(workoutStore)
            }
            .sheet(item: $viewingSession) { session in
                SessionDetailView(session: session)
            }
            .sheet(item: $editingWorkoutSelection) { selection in
                if let entity = workoutEntities.first(where: { $0.id == selection.id }) {
                    EditWorkoutView(entity: entity)
                        .environmentObject(workoutStore)
                } else {
                    Text("Workout konnte nicht geladen werden")
                }
            }
            .sheet(item: $shareItem) { item in
                ShareSheet(activityItems: [item.url])
            }
            .confirmationDialog(
                "Workout löschen?",
                isPresented: Binding(
                    get: { workoutToDelete != nil },
                    set: { if !$0 { workoutToDelete = nil } }
                ),
                presenting: workoutToDelete
            ) { workout in
                Button("Löschen", role: .destructive) {
                    deleteWorkout(id: workout.id)
                    workoutToDelete = nil
                }
                Button("Abbrechen", role: .cancel) {
                    workoutToDelete = nil
                }
            } message: { workout in
                Text("'\(workout.name)' wird unwiderruflich gelöscht.")
            }
    }
    
    private func addNavigationDestinations(to view: some View) -> some View {
        view
            .navigationDestination(item: $selectedWorkout) { selection in
                // Try to find the entity first in Query
                if let entity = workoutEntities.first(where: { $0.id == selection.id }) {
                    WorkoutDetailView(
                        entity: entity,
                        isActiveSession: workoutStore.activeSessionID == selection.id,
                        onActiveSessionEnd: {
                            endActiveSession()
                            // Navigation wird automatisch durch dismiss() gehandhabt
                        }
                    )
                    .environmentObject(workoutStore)
                    .environment(\.isInWorkoutDetail, true)
                    .onAppear {
                        withAnimation(.easeInOut(duration: 0.25)) {
                            workoutStore.isShowingWorkoutDetail = true
                        }
                    }
                    .onDisappear {
                        withAnimation(.easeInOut(duration: 0.25)) {
                            workoutStore.isShowingWorkoutDetail = false
                        }
                    }
                } else {
                    // Fallback: try direct fetch from modelContext
                    let selectionId = selection.id
                    let descriptor = FetchDescriptor<WorkoutEntity>(
                        predicate: #Predicate<WorkoutEntity> { entity in
                            entity.id == selectionId
                        }
                    )
                    if let entity = try? modelContext.fetch(descriptor).first {
                        WorkoutDetailView(
                            entity: entity,
                            isActiveSession: workoutStore.activeSessionID == selection.id,
                            onActiveSessionEnd: {
                                endActiveSession()
                                // Navigation wird automatisch durch dismiss() gehandhabt
                            }
                        )
                        .environmentObject(workoutStore)
                        .environment(\.isInWorkoutDetail, true)
                        .onAppear {
                            withAnimation(.easeInOut(duration: 0.25)) {
                                workoutStore.isShowingWorkoutDetail = true
                            }
                        }
                        .onDisappear {
                            withAnimation(.easeInOut(duration: 0.25)) {
                                workoutStore.isShowingWorkoutDetail = false
                            }
                        }
                    } else {
                        ErrorWorkoutView()
                    }
                }
            }
            .onReceive(workoutStore.$activeSessionID) { activeID in
                guard let activeID else { return }
                let workoutExists = workoutEntities.contains { $0.id == activeID }
                if !workoutExists {
                    // Try direct fetch before giving up
                    let activeSessionId = activeID
                    let descriptor = FetchDescriptor<WorkoutEntity>(
                        predicate: #Predicate<WorkoutEntity> { entity in
                            entity.id == activeSessionId
                        }
                    )
                    if (try? modelContext.fetch(descriptor).first) == nil {
                        workoutStore.activeSessionID = nil
                        WorkoutLiveActivityController.shared.end()
                    }
                }
                // Removed auto-navigation - user must explicitly tap ActiveWorkoutBar to resume
            }
            .onReceive(NotificationCenter.default.publisher(for: .resumeActiveWorkout)) { _ in
                if let activeID = workoutStore.activeSessionID {
                    selectedWorkout = WorkoutSelection(id: activeID)
                    if let entity = workoutEntities.first(where: { $0.id == activeID }) {
                        WorkoutLiveActivityController.shared.start(workoutName: entity.name)
                    }
                }
            }
    }
    
    private func addAlerts(to view: some View) -> some View {
        view
            .alert("Wirklich löschen?", isPresented: Binding(
                get: { workoutToDelete != nil },
                set: { if !$0 { workoutToDelete = nil } }
            )) {
                Button("Löschen", role: .destructive) {
                    if let id = workoutToDelete?.id {
                        deleteWorkout(id: id)
                    }
                    workoutToDelete = nil
                }
                Button("Abbrechen", role: .cancel) {
                    workoutToDelete = nil
                }
            } message: {
                Text("\(workoutToDelete?.name ?? "Workout") wird dauerhaft entfernt.")
            }
            .alert("Vorlage nicht gefunden", isPresented: $showingMissingTemplateAlert, presenting: missingTemplateName) { _ in
                Button("OK", role: .cancel) { missingTemplateName = nil }
            } message: { name in
                Text("Für die Session \(name) existiert keine gespeicherte Vorlage mehr.")
            }
            .alert("Home-Favoriten voll", isPresented: $showingHomeLimitAlert) {
                Button("Verstanden") { }
            } message: {
                Text("Du kannst maximal 4 Workouts als Home-Favoriten speichern.\n\nEntferne zuerst ein anderes Workout aus dem Home-Tab, um Platz zu schaffen.")
            }
            // Performance: Update cache only when entities change
            .onChange(of: workoutEntities) { _, newEntities in
                updateWorkoutCache(newEntities)
            }
            .onChange(of: sessionEntities) { _, newEntities in
                updateSessionCache(newEntities)
            }
            .onAppear {
                // Initial cache population
                updateWorkoutCache(workoutEntities)
                updateSessionCache(sessionEntities)
            }
    }
    
    @ViewBuilder
    private var headerSection: some View {
        Group {
            // Greeting header at top
            HStack(spacing: 12) {
                VStack(alignment: .leading, spacing: 2) {
                    let trimmedName = workoutStore.userProfile.name.trimmingCharacters(in: .whitespacesAndNewlines)
                    if !trimmedName.isEmpty {
                        Text("\(timeBasedGreeting),")
                            .font(.system(size: 32, weight: .semibold, design: .default))
                            .foregroundStyle(.primary)
                        Text("\(trimmedName)!")
                            .font(.system(size: 32, weight: .semibold, design: .default))
                            .foregroundStyle(.primary)
                    } else {
                        Text("\(timeBasedGreeting),")
                            .font(.system(size: 32, weight: .semibold, design: .default))
                            .foregroundStyle(.primary)
                        Button {
                            showingProfileEditor = true
                        } label: {
                            Text("Name!")
                                .font(.system(size: 32, weight: .semibold, design: .default))
                                .underline()
                                .foregroundStyle(AppTheme.powerOrange)
                        }
                        .buttonStyle(.plain)
                    }
                }
                Spacer()

                // Locker Number Badge
                Button {
                    showingLockerNumberInput = true
                } label: {
                    HStack(spacing: 6) {
                        Image(systemName: "lock.fill")
                            .font(.system(size: 14, weight: .semibold))
                        if let lockerNumber = workoutStore.userProfile.lockerNumber, !lockerNumber.isEmpty {
                            Text(lockerNumber)
                                .font(.system(size: 14, weight: .bold))
                                .monospacedDigit()
                        }
                    }
                    .foregroundStyle(.white)
                    .padding(.horizontal, 12)
                    .padding(.vertical, 8)
                    .background(
                        Capsule()
                            .fill(AppTheme.deepBlue)
                    )
                }
                .buttonStyle(.plain)

                Button {
                    showingSettings = true
                } label: {
                    Image(systemName: "gearshape.fill")
                        .font(.system(size: 20, weight: .medium))
                        .foregroundStyle(.primary)
                        .frame(width: 40, height: 40)
                        .background(
                            Circle()
                                .fill(Color(.systemGray5))
                        )
                }
                .buttonStyle(.plain)
            }
            .frame(maxWidth: .infinity, alignment: .leading)
            .padding(.top, 8)
        }
    }

    @ViewBuilder
    private func highlightSection(highlightSession: WorkoutSession?) -> some View {
        Group {
            if let session = highlightSession {
                Button {
                    viewSession(session)
                } label: {
                    WorkoutHighlightCard(workout: Workout(session: session))
                }
                .buttonStyle(.plain)
            } else {
                OnboardingCard(
                    onNavigateToWorkouts: {
                        // Navigation zum Workouts-Tab wird über ContentView gesteuert
                        NotificationCenter.default.post(name: .navigateToWorkoutsTab, object: nil)
                    },
                    onShowProfile: {
                        showingProfileEditor = true
                    }
                )
            }
        }
    }

    @ViewBuilder
    private func favoriteWorkoutsSection(favoritedWorkouts: [Workout]) -> some View {
        Group {
            if favoritedWorkouts.isEmpty {
                EmptyView()
            } else {
                // Performance: Explicit ID for better grid item recycling
                LazyVGrid(
                    columns: [
                        GridItem(.flexible(), spacing: 12),
                        GridItem(.flexible(), spacing: 12)
                    ],
                    spacing: 12
                ) {
                    ForEach(favoritedWorkouts, id: \.id) { workout in
                        WorkoutTileCard(
                            workout: workout,
                            isHomeFavorite: workout.isFavorite,
                            onTap: { startWorkout(with: workout.id) },
                            onEdit: { editWorkout(id: workout.id) },
                            onStart: { startWorkout(with: workout.id) },
                            onDelete: { workoutToDelete = workout },
                            onToggleHome: { toggleHomeFavorite(workoutID: workout.id) },
                            onDuplicate: { duplicateWorkout(id: workout.id) },
                            onShare: { shareWorkout(id: workout.id) }
                        )
                        .id(workout.id) // Performance: Explicit ID for optimal recycling
                    }
                }
            }
        }
    }

    @ViewBuilder
    private func savedWorkoutsSection(storedRoutines: [Workout]) -> some View {
        Group {
            if storedRoutines.isEmpty {
                VStack(spacing: 12) {
                    Text("Keine Workouts")
                        .font(.system(size: 18, weight: .semibold))
                        .foregroundStyle(.primary)
                    
                    Text("Erstelle dein erstes Workout im Workouts-Tab")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundStyle(.secondary)
                        .multilineTextAlignment(.center)
                }
                .frame(maxWidth: .infinity)
                .padding(.vertical, 32)
            } else {
                LazyVGrid(
                    columns: [
                        GridItem(.flexible(), spacing: 12),
                        GridItem(.flexible(), spacing: 12)
                    ],
                    spacing: 12
                ) {
                    ForEach(sortedWorkouts, id: \.id) { workout in
                        WorkoutTileWithMenu(
                            workout: workout,
                            onStart: { startWorkout(with: workout.id) },
                            onEdit: { editWorkout(id: workout.id) },
                            onDelete: { workoutToDelete = workout }
                        )
                    }
                }
            }
        }
    }



    private func startWorkout(with id: UUID) {
        // First, make sure the modelContext is saved and synced
        do {
            try modelContext.save()
        } catch {
            // Error handled silently
        }
        
        // Use the WorkoutStore's startSession method which handles the reset logic
        if workoutStore.activeSessionID == id {
            // If already active: just navigate to details
            selectedWorkout = WorkoutSelection(id: id)
            if let entity = workoutEntities.first(where: { $0.id == id }) {
                WorkoutLiveActivityController.shared.start(workoutName: entity.name)
            }
            return
        }
        
        // Start new session
        workoutStore.startSession(for: id)
        if workoutStore.activeSessionID == id {
            selectedWorkout = WorkoutSelection(id: id)
            if let entity = workoutEntities.first(where: { $0.id == id }) {
                WorkoutLiveActivityController.shared.start(workoutName: entity.name)
            }
        } else {
            // Error handled silently
        }
    }

    private func showWorkoutDetails(id: UUID) {
        selectedWorkout = WorkoutSelection(id: id)
        // aktive Session bleibt bestehen
    }

    private func editWorkout(id: UUID) {
        editingWorkoutSelection = WorkoutSelection(id: id)
    }

    private func deleteWorkout(id: UUID) {
        if let entity = workoutEntities.first(where: { $0.id == id }) {
            modelContext.delete(entity)
            try? modelContext.save()
        }
        if selectedWorkout?.id == id { selectedWorkout = nil }
        if workoutStore.activeSessionID == id {
            workoutStore.activeSessionID = nil
            WorkoutLiveActivityController.shared.end()
        }
        if editingWorkoutSelection?.id == id {
            editingWorkoutSelection = nil
        }
    }

    private func duplicateWorkout(id: UUID) {
        guard let originalEntity = workoutEntities.first(where: { $0.id == id }) else { return }

        // Erstelle neue WorkoutEntity als Kopie
        let duplicatedEntity = WorkoutEntity(
            name: "\(originalEntity.name) (Kopie)",
            date: Date(),
            exercises: [],
            defaultRestTime: originalEntity.defaultRestTime,
            duration: nil,
            notes: originalEntity.notes,
            isFavorite: false, // Nicht als Favorit markieren
            isSampleWorkout: false // Benutzer-Workout
        )

        // Kopiere alle Übungen mit Sets, sortiere nach order
        let sortedExercises = originalEntity.exercises.sorted { $0.order < $1.order }
        for (index, originalWorkoutExercise) in sortedExercises.enumerated() {
            let copiedWorkoutExercise = WorkoutExerciseEntity(
                exercise: originalWorkoutExercise.exercise,
                order: index
            )

            // Kopiere alle Sets
            for originalSet in originalWorkoutExercise.sets {
                let copiedSet = ExerciseSetEntity(
                    reps: originalSet.reps,
                    weight: originalSet.weight,
                    restTime: originalSet.restTime,
                    completed: false
                )
                copiedWorkoutExercise.sets.append(copiedSet)
                modelContext.insert(copiedSet)
            }

            duplicatedEntity.exercises.append(copiedWorkoutExercise)
            modelContext.insert(copiedWorkoutExercise)
        }

        // Speichere in SwiftData
        modelContext.insert(duplicatedEntity)
        try? modelContext.save()

        print("✅ Workout '\(originalEntity.name)' erfolgreich dupliziert")
    }

    private func shareWorkout(id: UUID) {
        guard let entity = workoutEntities.first(where: { $0.id == id }) else { return }

        do {
            // Workout in ShareableWorkout konvertieren
            let shareable = ShareableWorkout.from(entity: entity)

            // Als JSON-Datei exportieren
            let fileURL = try shareable.exportToFile()

            // Share-Sheet öffnen
            shareItem = ShareItem(url: fileURL)

            print("✅ Workout '\(entity.name)' bereit zum Teilen")
        } catch {
            print("❌ Fehler beim Exportieren des Workouts: \(error)")
        }
    }

    private func importWorkout(from url: URL) {
        do {
            // JSON-Datei laden
            let shareable = try ShareableWorkout.importFrom(url: url)

            // Übungen aus DB laden
            let descriptor = FetchDescriptor<ExerciseEntity>()
            let exercises = try modelContext.fetch(descriptor)

            // WorkoutEntity erstellen
            let _ = try shareable.toWorkoutEntity(in: modelContext, exerciseEntities: exercises)

            print("✅ Workout '\(shareable.workout.name)' erfolgreich importiert")
        } catch {
            print("❌ Fehler beim Importieren des Workouts: \(error)")
        }
    }

    private func removeSession(id: UUID) {
        // Delete from SwiftData history
        if let entity = sessionEntities.first(where: { $0.id == id }) {
            modelContext.delete(entity)
            try? modelContext.save()
        }
        // Clear active session if needed
        if workoutStore.activeSessionID == id {
            workoutStore.activeSessionID = nil
            WorkoutLiveActivityController.shared.end()
        }
        if let session = viewingSession, session.id == id {
            viewingSession = nil
        }
    }

    private func startSession(_ session: WorkoutSession) {
        viewingSession = nil
        if let templateId = session.templateId,
           workoutEntities.contains(where: { $0.id == templateId }) {
            missingTemplateName = nil
            startWorkout(with: templateId)
        } else {
            missingTemplateName = session.name
            showingMissingTemplateAlert = true
        }
    }

    private func viewSession(_ session: WorkoutSession) {
        viewingSession = session
    }
    
    private func endActiveSession() {
        workoutStore.stopRest()
        workoutStore.activeSessionID = nil
        WorkoutLiveActivityController.shared.end()
    }
    
    private func toggleHomeFavorite(workoutID: UUID) {
        let success = workoutStore.toggleHomeFavorite(workoutID: workoutID)
        if !success {
            showingHomeLimitAlert = true
        } else {
            // Force a UI refresh by processing changes and refreshing the cache
            modelContext.processPendingChanges()
            try? modelContext.save()
            // Update cache immediately to trigger UI refresh
            updateWorkoutCache(workoutEntities)
        }
    }

    // MARK: - Performance Optimization: Cache Management

    /// Updates the workout cache by mapping entities to domain models
    /// Only called when workoutEntities actually change, not on every render
    private func updateWorkoutCache(_ entities: [WorkoutEntity]) {
        cachedWorkouts = entities.compactMap { mapWorkoutEntity($0) }
    }

    /// Updates the session cache by mapping entities to domain models
    /// Only called when sessionEntities actually change, not on every render
    private func updateSessionCache(_ entities: [WorkoutSessionEntity]) {
        cachedSessions = entities.map { WorkoutSession(entity: $0, in: modelContext) }
    }
}

struct WorkoutHighlightCard: View {
    let workout: Workout
    @Environment(\.colorScheme) private var colorScheme

    // Performance: Use cached DateFormatter
    private var dateText: String {
        DateFormatters.germanWeekdayDayMonth.string(from: workout.date)
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 20) {
            VStack(alignment: .leading, spacing: 8) {
                Text(dateText.uppercased())
                    .font(.system(size: 11, weight: .semibold))
                    .foregroundStyle(.white.opacity(0.8))
                    .tracking(0.5)

                Text(workout.name)
                    .font(.system(size: 28, weight: .bold))
                    .foregroundStyle(.white)
                    .lineLimit(2)
                    .minimumScaleFactor(0.8)
            }

            HStack(spacing: 12) {
                HStack(spacing: 6) {
                    Image(systemName: "dumbbell.fill")
                        .font(.system(size: 12, weight: .semibold))
                    Text("\(workout.exercises.count) Übungen")
                        .font(.system(size: 13, weight: .semibold))
                }
                .foregroundStyle(.white)
                .padding(.horizontal, 12)
                .padding(.vertical, 6)
                .background(
                    RoundedRectangle(cornerRadius: 12)
                        .fill(Color.white.opacity(0.2))
                        .overlay(
                            RoundedRectangle(cornerRadius: 12)
                                .stroke(Color.white.opacity(0.3), lineWidth: 0.5)
                        )
                )
                
                Spacer()
            }
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .frame(minHeight: 140)
        .padding(24)
        .background(
            RoundedRectangle(cornerRadius: 20, style: .continuous)
                .fill(AppTheme.deepBlue)
                .overlay(
                    RoundedRectangle(cornerRadius: 20, style: .continuous)
                        .stroke(Color.white.opacity(0.1), lineWidth: 1)
                )
        )
        .shadow(color: .black.opacity(0.1), radius: 10, x: 0, y: 4)
        .accessibilityElement(children: .combine)
    }
}

struct OnboardingCard: View {
    let onNavigateToWorkouts: () -> Void
    let onShowProfile: () -> Void
    @EnvironmentObject var workoutStore: WorkoutStore

    @State private var showCheckmark1 = false
    @State private var showCheckmark2 = false
    @State private var showCheckmark3 = false
    @State private var hasExploredWorkouts = false
    @State private var hasCreatedFirstWorkout = false
    @State private var hasSetupProfile = false

    var body: some View {
        VStack(spacing: 24) {
            VStack(spacing: 12) {
                Text("Willkommen bei GymBo!")
                    .font(.system(size: 26, weight: .bold))
                    .foregroundStyle(.white)
                    .multilineTextAlignment(.center)

                Text("Starte jetzt deine Trainingsreise und erreiche deine Fitnessziele.")
                    .font(.system(size: 15, weight: .medium))
                    .foregroundStyle(.white.opacity(0.9))
                    .multilineTextAlignment(.center)
            }

            VStack(spacing: 12) {
                // Button 1: Beispielworkouts
                Button {
                    if !hasExploredWorkouts {
                        workoutStore.markOnboardingStep(hasExploredWorkouts: true)
                        hasExploredWorkouts = true
                    }
                    onNavigateToWorkouts()
                } label: {
                    HStack(spacing: 12) {
                        Image(systemName: "list.bullet.clipboard.fill")
                            .font(.system(size: 18, weight: .semibold))
                            .frame(width: 24)

                        VStack(alignment: .leading, spacing: 2) {
                            Text("Entdecke Beispielworkouts")
                                .font(.system(size: 15, weight: .semibold))
                            Text("Finde vorgefertigte Trainings im Workouts-Tab")
                                .font(.system(size: 12, weight: .medium))
                                .opacity(0.85)
                        }

                        Spacer()

                        if hasExploredWorkouts {
                            AnimatedCheckmark(show: $showCheckmark1)
                        } else {
                            Image(systemName: "chevron.right")
                                .font(.system(size: 14, weight: .semibold))
                                .opacity(0.7)
                        }
                    }
                    .foregroundStyle(.white)
                    .padding(16)
                    .background(
                        RoundedRectangle(cornerRadius: 14)
                            .fill(Color.white.opacity(0.15))
                    )
                }
                .buttonStyle(.plain)

                // Button 2: Neues Workout erstellen
                Button {
                    onNavigateToWorkouts()
                } label: {
                    HStack(spacing: 12) {
                        Image(systemName: "plus.circle.fill")
                            .font(.system(size: 18, weight: .semibold))
                            .frame(width: 24)

                        VStack(alignment: .leading, spacing: 2) {
                            Text("Erstelle dein erstes Workout")
                                .font(.system(size: 15, weight: .semibold))
                            Text("Tippe auf '+' im Workouts-Tab")
                                .font(.system(size: 12, weight: .medium))
                                .opacity(0.85)
                        }

                        Spacer()

                        if hasCreatedFirstWorkout {
                            AnimatedCheckmark(show: $showCheckmark2)
                        } else {
                            Image(systemName: "chevron.right")
                                .font(.system(size: 14, weight: .semibold))
                                .opacity(0.7)
                        }
                    }
                    .foregroundStyle(.white)
                    .padding(16)
                    .background(
                        RoundedRectangle(cornerRadius: 14)
                            .fill(Color.white.opacity(0.15))
                    )
                }
                .buttonStyle(.plain)

                // Button 3: Profil einrichten
                Button {
                    onShowProfile()
                } label: {
                    HStack(spacing: 12) {
                        Image(systemName: "person.circle.fill")
                            .font(.system(size: 18, weight: .semibold))
                            .frame(width: 24)

                        VStack(alignment: .leading, spacing: 2) {
                            Text("Richte dein Profil ein")
                                .font(.system(size: 15, weight: .semibold))
                            Text("Personalisiere deine Trainingserfahrung")
                                .font(.system(size: 12, weight: .medium))
                                .opacity(0.85)
                        }

                        Spacer()

                        if hasSetupProfile {
                            AnimatedCheckmark(show: $showCheckmark3)
                        } else {
                            Image(systemName: "chevron.right")
                                .font(.system(size: 14, weight: .semibold))
                                .opacity(0.7)
                        }
                    }
                    .foregroundStyle(.white)
                    .padding(16)
                    .background(
                        RoundedRectangle(cornerRadius: 14)
                            .fill(Color.white.opacity(0.15))
                    )
                }
                .buttonStyle(.plain)
            }
        }
        .padding(.horizontal, 24)
        .padding(.top, 24)
        .padding(.bottom, 24)
        .frame(maxWidth: .infinity)
        .background(
            RoundedRectangle(cornerRadius: 20, style: .continuous)
                .fill(
                    LinearGradient(
                        colors: [AppTheme.mossGreen, AppTheme.turquoiseBoost],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .overlay(
                    RoundedRectangle(cornerRadius: 20, style: .continuous)
                        .stroke(Color.white.opacity(0.1), lineWidth: 1)
                )
        )
        .shadow(color: .black.opacity(0.1), radius: 10, x: 0, y: 4)
        .onAppear {
            let profile = workoutStore.userProfile
            hasExploredWorkouts = profile.hasExploredWorkouts
            hasCreatedFirstWorkout = profile.hasCreatedFirstWorkout
            hasSetupProfile = profile.hasSetupProfile

            if hasExploredWorkouts { showCheckmark1 = true }
            if hasCreatedFirstWorkout { showCheckmark2 = true }
            if hasSetupProfile { showCheckmark3 = true }
        }
        .onChange(of: workoutStore.profileUpdateTrigger) { _, _ in
            let profile = workoutStore.userProfile
            if profile.hasExploredWorkouts && !hasExploredWorkouts {
                hasExploredWorkouts = true
                showCheckmark1 = true
            }
            if profile.hasCreatedFirstWorkout && !hasCreatedFirstWorkout {
                hasCreatedFirstWorkout = true
                showCheckmark2 = true
            }
            if profile.hasSetupProfile && !hasSetupProfile {
                hasSetupProfile = true
                showCheckmark3 = true
            }
        }
    }
}

// MARK: - Animated Checkmark Component
struct AnimatedCheckmark: View {
    @Binding var show: Bool
    @State private var scale: CGFloat = 0.5
    @State private var opacity: Double = 0

    var body: some View {
        Image(systemName: "checkmark.circle.fill")
            .font(.system(size: 20, weight: .bold))
            .foregroundStyle(Color.green)
            .scaleEffect(scale)
            .opacity(opacity)
            .onAppear {
                if show {
                    withAnimation(.spring(response: 0.5, dampingFraction: 0.6, blendDuration: 0)) {
                        scale = 1.0
                        opacity = 1.0
                    }
                }
            }
            .onChange(of: show) { _, newValue in
                if newValue {
                    withAnimation(.spring(response: 0.5, dampingFraction: 0.6, blendDuration: 0)) {
                        scale = 1.0
                        opacity = 1.0
                    }
                }
            }
    }
}

// Minimal Wrap placeholder (no true wrapping; lays out vertically)
struct Wrap<Content: View>: View {
    var alignment: HorizontalAlignment = .leading
    var spacing: CGFloat = 8
    @ViewBuilder var content: () -> Content

    var body: some View {
        VStack(alignment: alignment, spacing: spacing) {
            content()
        }
    }
}

struct RecentActivityCard: View {
    let workouts: [WorkoutSession]
    let startAction: (WorkoutSession) -> Void
    let detailAction: (WorkoutSession) -> Void
    let deleteSessionAction: (WorkoutSession) -> Void
    let enableActions: Bool
    let showHeader: Bool
    
    // Performance: Use cached DateFormatter instead of creating new one on each access
    private var localizedDateFormatter: DateFormatter {
        DateFormatters.germanLong
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            if showHeader {
                Text("Letzte Sessions")
                    .font(.headline)
                    .padding(.horizontal, 8)
            }
            ForEach(workouts, id: \.id) { (session: WorkoutSession) in
                HStack {
                    VStack(alignment: .leading, spacing: 2) {
                        Text(session.name)
                            .font(.subheadline.weight(.semibold))
                        Text(localizedDateFormatter.string(from: session.date))
                            .font(.caption)
                            .foregroundStyle(.secondary)
                    }
                    Spacer()
                    if enableActions {
                        Menu {
                            Button("Starten") { startAction(session) }
                            Button("Details") { detailAction(session) }
                            Button("Löschen", role: .destructive) { deleteSessionAction(session) }
                        } label: {
                            Image(systemName: "ellipsis.circle")
                        }
                    }
                }
                .padding(.vertical, 6)
                .padding(.horizontal, 16)
            }
        }
// Removed .background modifier as per instructions
//        .background(
//            RoundedRectangle(cornerRadius: 16)
//                .fill(Color(.secondarySystemBackground))
//        )
    }
}

// ActiveWorkoutBar updated to show the rest timer
struct ActiveWorkoutBar: View {
    let workout: Workout
    let resumeAction: () -> Void
    let endAction: () -> Void
    @Environment(\.colorScheme) private var colorScheme
    @EnvironmentObject private var workoutStore: WorkoutStore

    private var restText: String? {
        guard let state = workoutStore.activeRestState, state.workoutId == workout.id else { return nil }
        let m = state.remainingSeconds / 60
        let s = state.remainingSeconds % 60
        return String(format: "%d:%02d", m, s)
    }

    var body: some View {
        HStack(spacing: 16) {
            VStack(alignment: .leading, spacing: 6) {
                Text("Aktives Workout")
                    .font(.system(size: 12, weight: .medium))
                    .foregroundStyle(.white.opacity(0.8))
                    .textCase(.uppercase)
                    .tracking(0.5)
                HStack(spacing: 10) {
                    Text(workout.name)
                        .font(.system(size: 20, weight: .bold))
                        .foregroundStyle(.white)
                        .lineLimit(1)
                    if let rest = restText {
                        Label(rest, systemImage: "timer")
                            .font(.system(size: 14, weight: .semibold))
                            .lineLimit(1)
                            .monospacedDigit()
                            .fixedSize(horizontal: true, vertical: false)
                            .minimumScaleFactor(0.8)
                            .contentTransition(.numericText())
                            .animation(.linear(duration: 0.3), value: restText)
                            .foregroundStyle(.white)
                            .padding(.horizontal, 10)
                            .padding(.vertical, 6)
                            .background(
                                Capsule()
                                    .fill(Color.white.opacity(0.2))
                            )
                            .transition(.scale.combined(with: .opacity))
                    }
                }
            }
            Spacer()
            Button(action: resumeAction) {
                Image(systemName: "arrow.up.right")
                    .font(.system(size: 18, weight: .bold))
                    .foregroundStyle(.white)
                    .frame(width: 50, height: 50)
                    .background(
                        RoundedRectangle(cornerRadius: 12, style: .continuous)
                            .fill(AppTheme.mossGreen)
                    )
                    .shadow(color: AppTheme.mossGreen.opacity(0.3), radius: 8, x: 0, y: 4)
            }
            .buttonStyle(ScaleButtonStyle())

            Button(action: endAction) {
                Image(systemName: "trash.fill")
                    .font(.system(size: 16, weight: .semibold))
                    .foregroundStyle(.white)
                    .frame(width: 50, height: 50)
                    .background(
                        RoundedRectangle(cornerRadius: 12, style: .continuous)
                            .fill(Color.red)
                    )
                    .shadow(color: Color.red.opacity(0.3), radius: 8, x: 0, y: 4)
            }
            .buttonStyle(ScaleButtonStyle())
        }
        .padding(.horizontal, 20)
        .padding(.vertical, 18)
        .background(
            RoundedRectangle(cornerRadius: 20, style: .continuous)
                .fill(
                    LinearGradient(
                        colors: [AppTheme.deepBlue, AppTheme.darkPurple],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
        )
        .overlay(
            RoundedRectangle(cornerRadius: 20, style: .continuous)
                .stroke(Color.white.opacity(0.15), lineWidth: 1)
        )
        .shadow(color: .black.opacity(0.2), radius: 16, x: 0, y: 8)
    }
}

struct SectionHeader: View {
    let title: String
    var subtitle: String? = nil

    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(title)
                .font(.headline)
            if let subtitle {
                Text(subtitle)
                    .font(.caption)
                    .foregroundStyle(.secondary)
            }
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding(.top, 4)
    }
}

struct WeekCalendarStrip: View {
    let sessions: [WorkoutSession]
    let showCalendar: () -> Void
    @Environment(\.calendar) private var calendar
    @Environment(\.colorScheme) private var colorScheme

    private var startOfWeek: Date {
        let cal = calendar
        let now = Date()
        let comps = cal.dateComponents([.yearForWeekOfYear, .weekOfYear], from: now)
        return cal.date(from: comps) ?? now
    }

    private var days: [Date] {
        (0..<7).compactMap { calendar.date(byAdding: .day, value: $0, to: startOfWeek) }
    }

    private func hasSession(on day: Date) -> Bool {
        sessions.contains { calendar.isDate($0.date, inSameDayAs: day) }
    }

    private var today: Date { Date() }
    
    // Performance: Use cached weekday symbols instead of creating DateFormatter
    private func localizedWeekdayAbbreviation(for date: Date) -> String {
        let weekdaySymbols = DateFormatters.germanVeryShortWeekdaySymbols()
        let weekday = Calendar.current.component(.weekday, from: date)
        return weekdaySymbols[weekday - 1]
    }

    var body: some View {
        Button(action: showCalendar) {
            HStack(spacing: 18) {
                ForEach(days, id: \.self) { day in
                    VStack(spacing: 6) {
                        Text("\(Calendar.current.component(.day, from: day))")
                            .font(.headline.weight(calendar.isDate(day, inSameDayAs: today) ? .bold : .regular))
                            .foregroundStyle(calendar.isDate(day, inSameDayAs: today) ? Color.primary : Color.primary.opacity(0.7))
                        Text(localizedWeekdayAbbreviation(for: day))
                            .font(.caption2.weight(.medium))
                            .foregroundStyle(calendar.isDate(day, inSameDayAs: today) ? Color.primary : Color.primary.opacity(0.6))
                        Circle()
                            .fill(hasSession(on: day) ? AppTheme.mossGreen : Color.secondary.opacity(0.3))
                            .frame(width: 6, height: 6)
                            .opacity(hasSession(on: day) ? 1 : 0.8)
                    }
                    .frame(maxWidth: .infinity)
                }
            }
            .padding(.horizontal, 16)
        }
        .buttonStyle(.plain)
        .accessibilityLabel("Kalender öffnen")
    }
}

struct WeeklyProgressCard: View {
    let workoutsThisWeek: Int
    let goal: Int
    @Environment(\.colorScheme) private var colorScheme

    private var progress: Double {
        guard goal > 0 else { return 0 }
        return min(Double(workoutsThisWeek) / Double(goal), 1.0)
    }

    var body: some View {
        HStack(spacing: 16) {
            VStack(alignment: .leading, spacing: 4) {
                Text("Wochenfortschritt")
                    .font(.system(size: 18, weight: .semibold))
                    .foregroundStyle(.white)
                
                Text("\(workoutsThisWeek) von \(max(goal, 1)) Trainings")
                    .font(.system(size: 14, weight: .medium))
                    .foregroundStyle(.white.opacity(0.75))
                
                Text("abgeschlossen")
                    .font(.system(size: 14, weight: .medium))
                    .foregroundStyle(.white.opacity(0.75))
            }
            
            Spacer()
            
            ZStack {
                Circle()
                    .stroke(Color.white.opacity(0.2), lineWidth: 4)
                    .frame(width: 50, height: 50)
                
                Circle()
                    .trim(from: 0, to: progress)
                    .stroke(
                        Color.white,
                        style: StrokeStyle(lineWidth: 4, lineCap: .round)
                    )
                    .rotationEffect(.degrees(-90))
                    .frame(width: 50, height: 50)
                    .animation(.easeInOut(duration: 1.0), value: progress)
                
                Text("\(workoutsThisWeek)")
                    .font(.system(size: 16, weight: .bold))
                    .foregroundStyle(.white)
            }
        }
        .padding(20)
        .background(
            RoundedRectangle(cornerRadius: 16, style: .continuous)
                .fill(AppTheme.cardBackground)
        )
        .overlay(
            RoundedRectangle(cornerRadius: 16, style: .continuous)
                .stroke(Color.white.opacity(0.05), lineWidth: 1)
        )
    }
}

struct WeeklySnapshotCard: View {
    let workoutsThisWeek: Int
    let minutesThisWeek: Int
    let goal: Int
    
    private var progress: Double {
        guard goal > 0 else { return 0 }
        return min(Double(workoutsThisWeek) / Double(goal), 1.0)
    }
    
    private var progressColor: Color {
        let hue = progress * 0.33 // 0 = rot, 0.33 = grün
        return Color(hue: hue, saturation: 0.8, brightness: 0.8)
    }

    var body: some View {
        HStack(spacing: 20) {
            VStack(alignment: .leading, spacing: 6) {
                Text("Diese Woche")
                    .font(.caption)
                    .foregroundStyle(.secondary)
                Text("\(workoutsThisWeek) Trainings")
                    .font(.headline)
                Text("\(minutesThisWeek) Minuten")
                    .font(.subheadline)
                    .foregroundStyle(.secondary)
            }
            
            Spacer()
            
            VStack(spacing: 8) {
                ZStack {
                    // Hintergrund-Ring
                    Circle()
                        .stroke(Color(.systemGray5), lineWidth: 6)
                        .frame(width: 60, height: 60)
                    
                    // Fortschritts-Ring
                    Circle()
                        .trim(from: 0, to: progress)
                        .stroke(
                            progressColor,
                            style: StrokeStyle(lineWidth: 6, lineCap: .round)
                        )
                        .frame(width: 60, height: 60)
                        .rotationEffect(.degrees(-90))
                        .animation(.easeInOut(duration: 0.6), value: progress)
                    
                    // Zentraler Text
                    VStack(spacing: -2) {
                        Text("\(workoutsThisWeek)")
                            .font(.callout)
                            .fontWeight(.bold)
                            .foregroundStyle(.primary)
                        Text("\(goal)")
                            .font(.caption)
                            .fontWeight(.medium)
                            .foregroundStyle(.secondary)
                    }
                }
                
                Text("Ziel")
                    .font(.caption2)
                    .foregroundStyle(.secondary)
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color(.secondarySystemBackground))
        )
    }
}

struct WorkoutTile: View {
    let workout: Workout
    @Environment(\.colorScheme) private var colorScheme
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text(workout.name)
                        .font(.headline)
                        .fontWeight(.semibold)
                        .lineLimit(2)
                        .multilineTextAlignment(.leading)
                    
                    Text("\(workout.exercises.count) Übungen")
                        .font(.subheadline)
                        .foregroundStyle(.secondary)
                }
                
                Spacer()
            }
            
            // Menu dots at bottom right
            HStack {
                Spacer()
                Image(systemName: "ellipsis")
                    .font(.system(size: 16, weight: .medium))
                    .foregroundStyle(.secondary)
            }
        }
        .padding(16)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color(.secondarySystemBackground))
                .overlay(
                    RoundedRectangle(cornerRadius: 16)
                        .stroke(Color(.systemGray4), lineWidth: 1)
                )
        )
    }
}

struct WorkoutTileWithMenu: View {
    let workout: Workout
    let onStart: () -> Void
    let onEdit: () -> Void  
    let onDelete: () -> Void
    
    @Environment(\.colorScheme) private var colorScheme
    @State private var showingActionSheet = false
    
    private func workoutCategory(for workout: Workout) -> String {
        let exerciseNames = workout.exercises.map { $0.exercise.name.lowercased() }
        
        let machineKeywords = ["maschine", "machine", "lat", "press", "curl", "extension", "row"]
        let freeWeightKeywords = ["hantel", "kurzhantel", "langhantel", "dumbbell", "barbell", "squat", "deadlift", "bench"]
        
        let hasMachine = exerciseNames.contains { name in
            machineKeywords.contains { keyword in name.contains(keyword) }
        }
        
        let hasFreeWeight = exerciseNames.contains { name in
            freeWeightKeywords.contains { keyword in name.contains(keyword) }
        }
        
        if hasMachine && hasFreeWeight {
            return "Mixed"
        } else if hasMachine {
            return "Maschinen"
        } else if hasFreeWeight {
            return "Freie Gewichte"
        } else {
            return "Training"
        }
    }
    
    var body: some View {
        Button {
            onStart()
        } label: {
            VStack(alignment: .leading, spacing: 12) {
                VStack(alignment: .leading, spacing: 4) {
                    Text(workout.name)
                        .font(.system(size: 18, weight: .semibold))
                        .foregroundStyle(.primary)
                        .lineLimit(2)
                        .multilineTextAlignment(.leading)
                        .frame(maxWidth: .infinity, alignment: .leading)
                    
                    Text(workoutCategory(for: workout))
                        .font(.system(size: 14, weight: .medium))
                        .foregroundStyle(.secondary)
                        .lineLimit(1)
                }
                
                Spacer()
                
                HStack {
                    Text("\(workout.exercises.count) Übungen")
                        .font(.system(size: 12, weight: .medium))
                        .foregroundStyle(.secondary)
                    
                    Spacer()
                    
                    Button {
                        showingActionSheet = true
                    } label: {
                        Image(systemName: "ellipsis")
                            .font(.system(size: 14, weight: .medium))
                            .foregroundStyle(.tertiary)
                            .frame(width: 24, height: 24)
                    }
                    .buttonStyle(.plain)
                }
            }
            .padding(16)
            .frame(maxWidth: .infinity, minHeight: 110, alignment: .topLeading)
            .background(
                RoundedRectangle(cornerRadius: 16, style: .continuous)
                    .fill(Color(.systemBackground))
                    .overlay(
                        RoundedRectangle(cornerRadius: 16, style: .continuous)
                            .stroke(Color(.systemGray5), lineWidth: 1)
                    )
            )
            .shadow(color: .black.opacity(0.04), radius: 8, x: 0, y: 2)
        }
        .buttonStyle(.plain)
        .confirmationDialog(
            "Workout-Optionen",
            isPresented: $showingActionSheet,
            titleVisibility: .hidden
        ) {
            Button("Bearbeiten") {
                onEdit()
            }
            
            Button("Löschen", role: .destructive) {
                onDelete()
            }
            
            Button("Abbrechen", role: .cancel) { }
        }
    }
}

struct WorkoutRow: View {
    let workout: Workout
    var body: some View {
        HStack {
            VStack(alignment: .leading, spacing: 4) {
                Text(workout.name)
                    .font(.headline)
                Text({
                    let formatter = DateFormatter()
                    formatter.locale = Locale(identifier: "de_DE")
                    formatter.dateStyle = .medium
                    formatter.timeStyle = .none
                    return formatter.string(from: workout.date)
                }())
                    .font(.caption)
                    .foregroundStyle(.secondary)
            }
            Spacer()
            Text("\(workout.exercises.count) Übungen")
                .font(.caption)
                .foregroundStyle(.secondary)
        }
        .padding(.vertical, 10)
        .padding(.horizontal, 12)
// Removed .background modifier as per instructions
//        .background(
//            RoundedRectangle(cornerRadius: 12)
//                .fill(Color(.systemBackground))
//                .overlay(
//                    RoundedRectangle(cornerRadius: 12)
//                        .stroke(Color(.systemGray4), lineWidth: 1)
//                )
//        )
    }
}

struct MetricChip: View {
    let icon: String
    let text: String
    let tint: Color

    var body: some View {
        HStack(spacing: 6) {
            Image(systemName: icon)
            Text(text)
                .font(.caption.weight(.semibold))
        }
        .foregroundStyle(tint)
        .padding(.horizontal, 10)
        .padding(.vertical, 6)
        .background(tint.opacity(0.12), in: Capsule())
    }
}

struct CapsuleTag: View {
    let text: String

    var body: some View {
        Text(text)
            .font(.caption)
            .lineLimit(1)
            .truncationMode(.tail)
            .padding(.horizontal, 10)
            .padding(.vertical, 6)
            .background(
                Capsule()
                    .fill(Color.white.opacity(0.15))
            )
            .foregroundStyle(.white)
            .fixedSize(horizontal: true, vertical: false)
    }
}

// MARK: - Session Detail UI Components moved to SessionDetailComponents.swift
// MARK: - Session Statistics moved to SessionStatistics.swift
// MARK: - SessionDetailView moved to SessionDetailView.swift

// Keep only WorkoutHighlightCard here as it's used in WorkoutsHomeView
    let icon: String
    let value: String
    let label: String
    let color: Color

    var body: some View {
        VStack(spacing: 8) {
            Image(systemName: icon)
                .font(.system(size: 24, weight: .semibold))
                .foregroundStyle(color)

            Text(value)
                .font(.system(size: 20, weight: .bold))
                .foregroundStyle(.primary)
                .lineLimit(1)
                .minimumScaleFactor(0.8)

            Text(label)
                .font(.system(size: 12, weight: .medium))
                .foregroundStyle(.secondary)
                .lineLimit(2)
                .multilineTextAlignment(.center)
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, 16)
        .padding(.horizontal, 12)
        .background(
            RoundedRectangle(cornerRadius: 16, style: .continuous)
                .fill(Color(.systemBackground))
                .overlay(
                    RoundedRectangle(cornerRadius: 16, style: .continuous)
                        .stroke(color.opacity(0.2), lineWidth: 1.5)
                )
        )
        .shadow(color: .black.opacity(0.04), radius: 8, x: 0, y: 2)
        .accessibilityElement(children: .combine)
        .accessibilityLabel("\(label): \(value)")
    }
}

struct ExerciseDetailCard: View {
    let statistic: ExerciseStatistic
    let sets: [ExerciseSet]
    @State private var isExpanded: Bool = false

    private var progressionColor: Color {
        guard let progression = statistic.progressionPercentage else { return .gray }
        if progression > 0 { return AppTheme.mossGreen }
        if progression < 0 { return .red }
        return .gray
    }

    private var progressionIcon: String {
        guard let progression = statistic.progressionPercentage else { return "minus" }
        if progression > 0 { return "arrow.up.right" }
        if progression < 0 { return "arrow.down.right" }
        return "minus"
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Header
            Button {
                withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                    isExpanded.toggle()
                }
            } label: {
                HStack(spacing: 12) {
                    Image(systemName: "dumbbell.fill")
                        .font(.system(size: 16, weight: .semibold))
                        .foregroundStyle(AppTheme.deepBlue)
                        .frame(width: 32, height: 32)
                        .background(
                            Circle()
                                .fill(AppTheme.deepBlue.opacity(0.1))
                        )

                    VStack(alignment: .leading, spacing: 4) {
                        HStack(spacing: 8) {
                            Text(statistic.exerciseName)
                                .font(.system(size: 16, weight: .semibold))
                                .foregroundStyle(.primary)
                                .lineLimit(1)

                            // Progression Badge
                            if let progression = statistic.progressionPercentage {
                                HStack(spacing: 4) {
                                    Image(systemName: progressionIcon)
                                        .font(.system(size: 10, weight: .bold))
                                    Text(String(format: "%.1f%%", abs(progression)))
                                        .font(.system(size: 11, weight: .bold))
                                }
                                .foregroundStyle(.white)
                                .padding(.horizontal, 8)
                                .padding(.vertical, 4)
                                .background(
                                    Capsule()
                                        .fill(progressionColor)
                                )
                            }
                        }

                        Text("\(statistic.completedSets)/\(statistic.totalSets) Sätze • \(Int(statistic.totalVolume)) kg Volumen")
                            .font(.system(size: 13, weight: .medium))
                            .foregroundStyle(.secondary)
                    }

                    Spacer()

                    Image(systemName: isExpanded ? "chevron.up" : "chevron.down")
                        .font(.system(size: 14, weight: .semibold))
                        .foregroundStyle(.tertiary)
                }
            }
            .buttonStyle(.plain)

            // Expandable Details
            if isExpanded {
                VStack(spacing: 8) {
                    // Stats Summary
                    HStack(spacing: 16) {
                        VStack(alignment: .leading, spacing: 4) {
                            Text("Max Gewicht")
                                .font(.system(size: 11, weight: .medium))
                                .foregroundStyle(.secondary)
                            Text("\(Int(statistic.maxWeight)) kg")
                                .font(.system(size: 14, weight: .bold))
                                .foregroundStyle(.primary)
                        }

                        Divider()
                            .frame(height: 30)

                        VStack(alignment: .leading, spacing: 4) {
                            Text("Ø Wiederholungen")
                                .font(.system(size: 11, weight: .medium))
                                .foregroundStyle(.secondary)
                            Text(String(format: "%.1f", statistic.averageReps))
                                .font(.system(size: 14, weight: .bold))
                                .foregroundStyle(.primary)
                        }

                        Spacer()
                    }
                    .padding(.horizontal, 8)
                    .padding(.vertical, 8)
                    .background(
                        RoundedRectangle(cornerRadius: 10)
                            .fill(Color(.systemGray6))
                    )

                    // Sets Table
                    VStack(spacing: 6) {
                        // Table Header
                        HStack {
                            Text("Set")
                                .font(.system(size: 11, weight: .semibold))
                                .foregroundStyle(.secondary)
                                .frame(width: 40, alignment: .leading)

                            Text("Gewicht")
                                .font(.system(size: 11, weight: .semibold))
                                .foregroundStyle(.secondary)
                                .frame(maxWidth: .infinity, alignment: .leading)

                            Text("Wdh.")
                                .font(.system(size: 11, weight: .semibold))
                                .foregroundStyle(.secondary)
                                .frame(width: 50, alignment: .leading)

                            Text("Status")
                                .font(.system(size: 11, weight: .semibold))
                                .foregroundStyle(.secondary)
                                .frame(width: 50, alignment: .center)
                        }
                        .padding(.horizontal, 8)
                        .padding(.vertical, 6)

                        Divider()

                        // Table Rows
                        ForEach(Array(sets.enumerated()), id: \.element.id) { index, set in
                            HStack {
                                Text("\(index + 1)")
                                    .font(.system(size: 13, weight: .medium))
                                    .foregroundStyle(.secondary)
                                    .frame(width: 40, alignment: .leading)

                                Text("\(Int(set.weight)) kg")
                                    .font(.system(size: 13, weight: .semibold))
                                    .foregroundStyle(.primary)
                                    .frame(maxWidth: .infinity, alignment: .leading)

                                Text("\(set.reps)")
                                    .font(.system(size: 13, weight: .semibold))
                                    .foregroundStyle(.primary)
                                    .frame(width: 50, alignment: .leading)

                                Image(systemName: set.completed ? "checkmark.circle.fill" : "circle")
                                    .font(.system(size: 16, weight: .semibold))
                                    .foregroundStyle(set.completed ? AppTheme.mossGreen : Color(.systemGray4))
                                    .frame(width: 50, alignment: .center)
                            }
                            .padding(.horizontal, 8)
                            .padding(.vertical, 4)
                        }
                    }
                    .padding(.vertical, 6)
                    .background(
                        RoundedRectangle(cornerRadius: 10)
                            .fill(Color(.systemBackground))
                    )
                }
                .transition(.opacity.combined(with: .move(edge: .top)))
            }
        }
        .padding(16)
        .background(
            RoundedRectangle(cornerRadius: 16, style: .continuous)
                .fill(Color(.systemBackground))
                .overlay(
                    RoundedRectangle(cornerRadius: 16, style: .continuous)
                        .stroke(Color(.systemGray5), lineWidth: 1)
                )
        )
        .shadow(color: .black.opacity(0.04), radius: 8, x: 0, y: 2)
        .accessibilityElement(children: .contain)
        .accessibilityLabel("\(statistic.exerciseName), \(statistic.completedSets) von \(statistic.totalSets) Sätzen abgeschlossen")
        .accessibilityHint(isExpanded ? "Doppeltippen zum Ausblenden der Details" : "Doppeltippen zum Anzeigen der Details")
    }
}

struct VolumeChart: View {
    let dataPoints: [VolumeDataPoint]

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Volumenverteilung")
                .font(.system(size: 18, weight: .semibold))
                .foregroundStyle(.primary)

            if dataPoints.isEmpty {
                Text("Keine Daten verfügbar")
                    .font(.system(size: 14, weight: .medium))
                    .foregroundStyle(.secondary)
                    .frame(maxWidth: .infinity, alignment: .center)
                    .padding(.vertical, 32)
            } else {
                Chart {
                    ForEach(dataPoints) { point in
                        BarMark(
                            x: .value("Übung", point.exerciseName),
                            y: .value("Volumen", point.volume)
                        )
                        .foregroundStyle(
                            LinearGradient(
                                colors: [AppTheme.deepBlue, AppTheme.turquoiseBoost],
                                startPoint: .bottom,
                                endPoint: .top
                            )
                        )
                        .cornerRadius(8)
                    }
                }
                .chartYAxis {
                    AxisMarks(position: .leading) { value in
                        AxisGridLine()
                        AxisValueLabel {
                            if let intValue = value.as(Double.self) {
                                Text("\(Int(intValue)) kg")
                                    .font(.system(size: 11, weight: .medium))
                                    .foregroundStyle(.secondary)
                            }
                        }
                    }
                }
                .chartXAxis {
                    AxisMarks { value in
                        AxisValueLabel(orientation: .verticalReversed) {
                            if let name = value.as(String.self) {
                                Text(name)
                                    .font(.system(size: 9, weight: .medium))
                                    .foregroundStyle(.secondary)
                                    .lineLimit(2)
                                    .multilineTextAlignment(.leading)
                                    .fixedSize(horizontal: false, vertical: true)
                            }
                        }
                    }
                }
                .frame(height: 240)
            }
        }
        .padding(16)
        .background(
            RoundedRectangle(cornerRadius: 16, style: .continuous)
                .fill(Color(.systemBackground))
                .overlay(
                    RoundedRectangle(cornerRadius: 16, style: .continuous)
                        .stroke(Color(.systemGray5), lineWidth: 1)
                )
        )
        .shadow(color: .black.opacity(0.04), radius: 8, x: 0, y: 2)
        .accessibilityElement(children: .contain)
        .accessibilityLabel("Volumenverteilung Diagramm")
    }
}

// Re-add SessionDetailView to fix missing type
struct SessionDetailView: View {
    let session: WorkoutSession
    @Environment(\.dismiss) private var dismiss
    @Environment(\.modelContext) private var modelContext
    @EnvironmentObject private var workoutStore: WorkoutStore

    @State private var showingRestartConfirmation = false
    @State private var previousSessions: [WorkoutSessionEntity] = []

    // Performance: Use cached DateFormatter
    private var localizedDateFormatter: DateFormatter {
        DateFormatters.germanMedium
    }

    // MARK: - Computed Statistics

    private var totalVolume: Double {
        session.exercises.reduce(0.0) { sessionTotal, exercise in
            let exerciseVolume = exercise.sets
                .filter { $0.completed }
                .reduce(0.0) { $0 + ($1.weight * Double($1.reps)) }
            return sessionTotal + exerciseVolume
        }
    }

    private var completionRate: Double {
        let allSets = session.exercises.flatMap { $0.sets }
        guard !allSets.isEmpty else { return 0 }
        let completedCount = allSets.filter { $0.completed }.count
        return Double(completedCount) / Double(allSets.count) * 100
    }

    private var totalSetsCompleted: Int {
        session.exercises.flatMap { $0.sets }.filter { $0.completed }.count
    }

    private var totalSets: Int {
        session.exercises.flatMap { $0.sets }.count
    }

    private var totalReps: Int {
        session.exercises.flatMap { $0.sets }
            .filter { $0.completed }
            .reduce(0) { $0 + $1.reps }
    }

    private var averageRestTime: TimeInterval {
        let allSets = session.exercises.flatMap { $0.sets }
        guard !allSets.isEmpty else { return 0 }
        let totalRest = allSets.reduce(0.0) { $0 + $1.restTime }
        return totalRest / Double(allSets.count)
    }

    private var topSet: (exercise: String, set: ExerciseSet)? {
        var maxVolume = 0.0
        var topSet: (String, ExerciseSet)? = nil

        for exercise in session.exercises {
            for set in exercise.sets where set.completed {
                let volume = set.weight * Double(set.reps)
                if volume > maxVolume {
                    maxVolume = volume
                    topSet = (exercise.exercise.name, set)
                }
            }
        }
        return topSet
    }

    private var exerciseStatistics: [ExerciseStatistic] {
        session.exercises.map { workoutExercise in
            let completedSets = workoutExercise.sets.filter { $0.completed }
            let maxWeight = completedSets.map { $0.weight }.max() ?? 0
            let totalVolume = completedSets.reduce(0.0) { $0 + ($1.weight * Double($1.reps)) }
            let avgReps = completedSets.isEmpty ? 0 : Double(completedSets.reduce(0) { $0 + $1.reps }) / Double(completedSets.count)

            // Calculate progression
            let progression = calculateProgression(for: workoutExercise.exercise.id, currentVolume: totalVolume)

            return ExerciseStatistic(
                id: workoutExercise.id,
                exerciseName: workoutExercise.exercise.name,
                maxWeight: maxWeight,
                totalVolume: totalVolume,
                averageReps: avgReps,
                completedSets: completedSets.count,
                totalSets: workoutExercise.sets.count,
                progressionPercentage: progression
            )
        }
    }

    private func calculateProgression(for exerciseId: UUID, currentVolume: Double) -> Double? {
        // Find previous session with same exercise
        let previousSessionsWithExercise = previousSessions.filter { sessionEntity in
            sessionEntity.exercises.contains(where: { $0.exercise?.id == exerciseId })
        }

        guard let lastSession = previousSessionsWithExercise.first,
              let lastExercise = lastSession.exercises.first(where: { $0.exercise?.id == exerciseId }) else {
            return nil
        }

        // Calculate previous volume
        let previousVolume = lastExercise.sets
            .filter { $0.completed }
            .reduce(0.0) { $0 + ($1.weight * Double($1.reps)) }

        guard previousVolume > 0 else { return nil }

        // Calculate percentage change
        let change = ((currentVolume - previousVolume) / previousVolume) * 100
        return change
    }

    private var volumeDataPoints: [VolumeDataPoint] {
        exerciseStatistics.map { stat in
            VolumeDataPoint(exerciseName: stat.exerciseName, volume: stat.totalVolume)
        }
    }

    var body: some View {
        NavigationStack {
            ZStack(alignment: .bottom) {
                // Main Content
                ScrollView(showsIndicators: true) {
                    VStack(spacing: 20) {
                        // Hero Section
                        heroSection
                            .padding(.horizontal, 20)
                            .padding(.top, 8)

                        // Summary Grid
                        summaryGrid
                            .padding(.horizontal, 20)

                        // Chart Section
                        if !volumeDataPoints.isEmpty {
                            VolumeChart(dataPoints: volumeDataPoints)
                                .padding(.horizontal, 20)
                        }

                        // Exercises List
                        exercisesList
                            .padding(.horizontal, 20)

                        // Notes Section
                        if !session.notes.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                            notesSection
                                .padding(.horizontal, 20)
                        }
                    }
                    .padding(.bottom, 100) // Space for toolbar
                }
                .background(Color(.systemGroupedBackground))

                // Bottom Toolbar
                actionToolbar
            }
            .navigationTitle("Session Details")
            .navigationBarTitleDisplayMode(.inline)
            .confirmationDialog(
                "Workout erneut starten?",
                isPresented: $showingRestartConfirmation,
                titleVisibility: .visible
            ) {
                Button("Starten") {
                    restartWorkout()
                }
                Button("Abbrechen", role: .cancel) { }
            } message: {
                Text("Das Workout '\(session.name)' wird als neue Session gestartet.")
            }
            .onAppear {
                loadPreviousSessions()
            }
        }
    }

    // MARK: - Data Loading

    private func loadPreviousSessions() {
        let descriptor = FetchDescriptor<WorkoutSessionEntity>(
            sortBy: [SortDescriptor(\.date, order: .reverse)]
        )

        if let allSessions = try? modelContext.fetch(descriptor) {
            // Filter sessions that are older than current session
            previousSessions = allSessions.filter { $0.date < session.date }
        }
    }

    // MARK: - View Builders

    @ViewBuilder
    private var heroSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Date Label
            Text(DateFormatters.germanWeekdayDayMonth.string(from: session.date).uppercased())
                .font(.system(size: 11, weight: .semibold))
                .foregroundStyle(.white.opacity(0.8))
                .tracking(0.5)

            // Workout Name
            Text(session.name)
                .font(.system(size: 28, weight: .bold))
                .foregroundStyle(.white)
                .lineLimit(2)

            HStack(spacing: 12) {
                // Duration Badge
                if let duration = session.duration {
                    HStack(spacing: 6) {
                        Image(systemName: "clock.fill")
                            .font(.system(size: 12, weight: .semibold))
                        Text("\(Int(duration / 60)) min")
                            .font(.system(size: 13, weight: .semibold))
                    }
                    .foregroundStyle(.white)
                    .padding(.horizontal, 12)
                    .padding(.vertical, 6)
                    .background(
                        RoundedRectangle(cornerRadius: 12)
                            .fill(Color.white.opacity(0.2))
                    )
                }

                // Completion Badge
                HStack(spacing: 6) {
                    Image(systemName: "checkmark.circle.fill")
                        .font(.system(size: 12, weight: .semibold))
                    Text("\(Int(completionRate))%")
                        .font(.system(size: 13, weight: .semibold))
                }
                .foregroundStyle(.white)
                .padding(.horizontal, 12)
                .padding(.vertical, 6)
                .background(
                    RoundedRectangle(cornerRadius: 12)
                        .fill(Color.white.opacity(0.2))
                )

                Spacer()
            }
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding(24)
        .background(
            RoundedRectangle(cornerRadius: 20, style: .continuous)
                .fill(
                    LinearGradient(
                        colors: [AppTheme.deepBlue, AppTheme.darkPurple],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .overlay(
                    RoundedRectangle(cornerRadius: 20, style: .continuous)
                        .stroke(Color.white.opacity(0.1), lineWidth: 1)
                )
        )
        .shadow(color: .black.opacity(0.1), radius: 10, x: 0, y: 4)
        .accessibilityElement(children: .combine)
        .accessibilityLabel("Workout \(session.name), am \(DateFormatters.germanWeekdayDayMonth.string(from: session.date)), Abschlussrate \(Int(completionRate)) Prozent")
    }

    @ViewBuilder
    private var summaryGrid: some View {
        LazyVGrid(
            columns: [
                GridItem(.flexible(), spacing: 12),
                GridItem(.flexible(), spacing: 12)
            ],
            spacing: 12
        ) {
            SessionStatCard(
                icon: "scalemass.fill",
                value: "\(Int(totalVolume)) kg",
                label: "Gesamtvolumen",
                color: AppTheme.powerOrange
            )

            SessionStatCard(
                icon: "square.stack.3d.up.fill",
                value: "\(totalSetsCompleted)/\(totalSets)",
                label: "Sätze",
                color: AppTheme.mossGreen
            )

            SessionStatCard(
                icon: "repeat",
                value: "\(totalReps)",
                label: "Wiederholungen",
                color: AppTheme.turquoiseBoost
            )

            SessionStatCard(
                icon: "timer",
                value: "\(Int(averageRestTime))s",
                label: "Ø Pause",
                color: AppTheme.deepBlue
            )
        }
    }

    @ViewBuilder
    private var exercisesList: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Übungen")
                .font(.system(size: 20, weight: .bold))
                .foregroundStyle(.primary)
                .padding(.horizontal, 4)

            ForEach(session.exercises, id: \.id) { exercise in
                if let stat = exerciseStatistics.first(where: { $0.id == exercise.id }) {
                    ExerciseDetailCard(
                        statistic: stat,
                        sets: exercise.sets
                    )
                }
            }
        }
    }

    @ViewBuilder
    private var notesSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Notizen")
                .font(.system(size: 18, weight: .semibold))
                .foregroundStyle(.primary)

            Text(session.notes)
                .font(.system(size: 14, weight: .medium))
                .foregroundStyle(.secondary)
                .padding(16)
                .frame(maxWidth: .infinity, alignment: .leading)
                .background(
                    RoundedRectangle(cornerRadius: 12, style: .continuous)
                        .fill(Color(.systemBackground))
                )
        }
        .padding(16)
        .background(
            RoundedRectangle(cornerRadius: 16, style: .continuous)
                .fill(Color(.systemBackground))
                .overlay(
                    RoundedRectangle(cornerRadius: 16, style: .continuous)
                        .stroke(Color(.systemGray5), lineWidth: 1)
                )
        )
        .shadow(color: .black.opacity(0.04), radius: 8, x: 0, y: 2)
    }

    @ViewBuilder
    private var actionToolbar: some View {
        HStack(spacing: 12) {
            Button {
                showingRestartConfirmation = true
            } label: {
                HStack(spacing: 8) {
                    Image(systemName: "arrow.clockwise")
                        .font(.system(size: 16, weight: .semibold))
                    Text("Erneut starten")
                        .font(.system(size: 16, weight: .bold))
                }
                .foregroundStyle(.white)
                .frame(maxWidth: .infinity)
                .padding(.vertical, 16)
                .background(
                    RoundedRectangle(cornerRadius: 16, style: .continuous)
                        .fill(
                            LinearGradient(
                                colors: [AppTheme.mossGreen, AppTheme.turquoiseBoost],
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                )
                .shadow(color: AppTheme.mossGreen.opacity(0.3), radius: 8, x: 0, y: 4)
            }
            .buttonStyle(ScaleButtonStyle())
            .accessibilityLabel("Workout erneut starten")
            .accessibilityHint("Startet das Workout \(session.name) als neue Session")
        }
        .padding(.horizontal, 20)
        .padding(.vertical, 16)
        .background(
            Rectangle()
                .fill(Color(.systemBackground))
                .shadow(color: .black.opacity(0.1), radius: 10, x: 0, y: -2)
        )
        .ignoresSafeArea(edges: .bottom)
    }

    // MARK: - Actions

    private func restartWorkout() {
        // Find template if exists
        if let templateId = session.templateId {
            // Try to start the template directly
            workoutStore.startSession(for: templateId)
            if workoutStore.activeSessionID == templateId {
                dismiss()
            }
        } else {
            // Create new template from session and start it
            createTemplateAndStart()
        }
    }

    private func createTemplateAndStart() {
        // Create a new WorkoutEntity from the session
        let newWorkout = WorkoutEntity(
            name: session.name,
            date: Date(),
            exercises: [],
            defaultRestTime: session.defaultRestTime,
            duration: nil,
            notes: session.notes,
            isFavorite: false,
            isSampleWorkout: false
        )

        // Fetch existing exercises from DB to match
        let descriptor = FetchDescriptor<ExerciseEntity>()
        guard let allExercises = try? modelContext.fetch(descriptor) else { return }

        // Copy exercises and sets
        for (index, exercise) in session.exercises.enumerated() {
            // Find matching ExerciseEntity by ID
            guard let exerciseEntity = allExercises.first(where: { $0.id == exercise.exercise.id }) else {
                continue
            }

            let workoutExercise = WorkoutExerciseEntity(
                exercise: exerciseEntity,
                order: index
            )

            for set in exercise.sets {
                let newSet = ExerciseSetEntity(
                    reps: set.reps,
                    weight: set.weight,
                    restTime: set.restTime,
                    completed: false // Reset completion status
                )
                workoutExercise.sets.append(newSet)
                modelContext.insert(newSet)
            }

            newWorkout.exercises.append(workoutExercise)
            modelContext.insert(workoutExercise)
        }

        modelContext.insert(newWorkout)
        try? modelContext.save()

        // Start the new workout
        workoutStore.startSession(for: newWorkout.id)
        if workoutStore.activeSessionID == newWorkout.id {
            dismiss()
        }
    }
}

// MARK: - Calendar Sessions Sheet
private struct CalendarSessionsView: View {
    @Environment(\.dismiss) private var dismiss

    @Query(sort: [SortDescriptor(\WorkoutSessionEntity.date, order: .reverse)])
    private var sessionEntities: [WorkoutSessionEntity]

    @State private var displayedMonth: Date = Date()
    @State private var selectedDate: Date = Calendar.current.startOfDay(for: Date())

    // Performance: Use cached DateFormatter
    private var monthTitle: String {
        DateFormatters.germanMonthYear.string(from: displayedMonth)
    }

    private var daysInMonth: [Date] {
        let cal = Calendar.current
        guard let range = cal.range(of: .day, in: .month, for: displayedMonth),
              let monthStart = cal.date(from: cal.dateComponents([.year, .month], from: displayedMonth)) else { return [] }
        return range.compactMap { day -> Date? in
            cal.date(byAdding: .day, value: day - 1, to: monthStart)
        }
    }

    private var gridDays: [Date?] {
        let cal = Calendar.current
        guard let monthStart = cal.date(from: cal.dateComponents([.year, .month], from: displayedMonth)) else { return [] }
        let weekday = cal.component(.weekday, from: monthStart) // 1=Sun...
        let leading = (weekday + 5) % 7 // convert to Monday=0 leading count
        let leadingPlaceholders: [Date?] = Array(repeating: nil, count: leading)
        return leadingPlaceholders + daysInMonth.map { Optional($0) }
    }

    private var sessionDays: Set<Date> {
        let cal = Calendar.current
        return Set(sessionEntities.map { cal.startOfDay(for: $0.date) })
    }

    private func sessions(on date: Date) -> [WorkoutSession] {
        let cal = Calendar.current
        let start = cal.startOfDay(for: date)
        let sameDay = sessionEntities.filter { cal.isDate($0.date, inSameDayAs: start) }
        return sameDay.map { WorkoutSession(entity: $0) }.sorted { $0.date > $1.date }
    }
    
    // Performance: Use cached weekday symbols
    private func localizedWeekdaySymbols() -> [String] {
        DateFormatters.germanVeryShortWeekdaySymbols()
    }

    var body: some View {
        NavigationStack {
            VStack(spacing: 12) {
                // Header with month navigation
                HStack {
                    Button { displayedMonth = Calendar.current.date(byAdding: .month, value: -1, to: displayedMonth) ?? displayedMonth } label: {
                        Image(systemName: "chevron.left")
                    }
                    Spacer()
                    Text(monthTitle)
                        .font(.headline)
                    Spacer()
                    Button { displayedMonth = Calendar.current.date(byAdding: .month, value: 1, to: displayedMonth) ?? displayedMonth } label: {
                        Image(systemName: "chevron.right")
                    }
                }
                .padding(.horizontal, 20)

                // Weekday symbols (localized)
                HStack {
                    ForEach(localizedWeekdaySymbols(), id: \.self) { d in
                        Text(d)
                            .font(.caption2)
                            .foregroundStyle(.secondary)
                            .frame(maxWidth: .infinity)
                    }
                }
                .padding(.horizontal, 20)

                // Calendar grid
                LazyVGrid(columns: Array(repeating: GridItem(.flexible(), spacing: 6), count: 7), spacing: 6) {
                    ForEach(gridDays.indices, id: \.self) { idx in
                        if let day = gridDays[idx] {
                            let cal = Calendar.current
                            let isToday = cal.isDateInToday(day)
                            let isSelected = cal.isDate(cal.startOfDay(for: day), inSameDayAs: selectedDate)
                            let hasSession = sessionDays.contains(cal.startOfDay(for: day))
                            VStack(spacing: 6) {
                                ZStack {
                                    Circle()
                                        .fill(
                                            isSelected ? AppTheme.mossGreen.opacity(0.25) : (isToday ? Color(.systemGray4) : Color(.systemGray6))
                                        )
                                        .frame(width: 36, height: 36)
                                    Text(String(cal.component(.day, from: day)))
                                        .font(.subheadline.weight(.medium))
                                }
                                Circle()
                                    .fill(AppTheme.darkPurple)
                                    .frame(width: 6, height: 6)
                                    .opacity(hasSession ? 1 : 0)
                            }
                            .contentShape(Rectangle())
                            .onTapGesture {
                                selectedDate = cal.startOfDay(for: day)
                            }
                        } else {
                            Color.clear.frame(height: 44)
                        }
                    }
                }
                .padding(.horizontal, 20)

                // Sessions list for selected date
                let daySessions = sessions(on: selectedDate)
                if daySessions.isEmpty {
                    VStack(spacing: 8) {
                        Text("Keine Trainings an diesem Tag")
                            .font(.subheadline)
                            .foregroundStyle(.secondary)
                    }
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 12)
                } else {
                    List {
                        ForEach(daySessions, id: \.id) { session in
                            VStack(alignment: .leading, spacing: 4) {
                                Text(session.name)
                                    .font(.subheadline.weight(.semibold))
                                HStack(spacing: 8) {
                                    Text({
                                        let formatter = DateFormatter()
                                        formatter.locale = Locale(identifier: "de_DE")
                                        formatter.timeStyle = .short
                                        formatter.dateStyle = .none
                                        return formatter.string(from: session.date)
                                    }())
                                        .font(.caption)
                                        .foregroundStyle(.secondary)
                                    Text("• \(session.exercises.count) Übungen")
                                        .font(.caption)
                                        .foregroundStyle(.secondary)
                                }
                            }
                            .padding(.vertical, 4)
                        }
                    }
                    .listStyle(.plain)
                }

                Spacer(minLength: 0)
            }
            .navigationTitle("Kalender")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Schließen") { dismiss() }
                }
            }
        }
    }
}

// MARK: - Date Helpers
private extension Calendar {
    func isDate(_ date1: Date, inSameDayAs startOfDay: Date) -> Bool {
        isDate(date1, equalTo: startOfDay, toGranularity: .day)
    }
}

private extension Array {
    func stablePartition(by isInFirstPartition: (Element) -> Bool) -> [Element] {
        var first: [Element] = []
        var second: [Element] = []
        for el in self {
            if isInFirstPartition(el) {
                first.append(el)
            } else {
                second.append(el)
            }
        }
        return first + second
    }
}

private extension View {
    func erasedToAnyView() -> AnyView { AnyView(self) }
}

// MARK: - Error View
struct ErrorWorkoutView: View {
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        VStack(spacing: 16) {
            Image(systemName: "exclamationmark.triangle")
                .font(.system(size: 50))
                .foregroundColor(.orange)
            Text("Workout nicht verfügbar")
                .font(.headline)
            Text("Das Workout konnte nicht geladen werden.")
                .font(.subheadline)
                .foregroundColor(.secondary)
            Button("Zurück") {
                dismiss()
            }
            .buttonStyle(.borderedProminent)
        }
        .padding()
    }
}

#Preview {
    ContentView()
}

extension Notification.Name {
    static let resumeActiveWorkout = Notification.Name("resumeActiveWorkout")
    static let navigateToWorkoutsTab = Notification.Name("navigateToWorkoutsTab")
}

// MARK: - Environment Key for WorkoutDetailView visibility
private struct IsInWorkoutDetailKey: EnvironmentKey {
    static let defaultValue: Bool = false
}

extension EnvironmentValues {
    var isInWorkoutDetail: Bool {
        get { self[IsInWorkoutDetailKey.self] }
        set { self[IsInWorkoutDetailKey.self] = newValue }
    }
}

// MARK: - Custom Button Styles for Smooth Interactions
struct ScaleButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed ? 0.92 : 1.0)
            .animation(.spring(response: 0.2, dampingFraction: 0.6), value: configuration.isPressed)
    }
}

// MARK: - Locker Number Input View
struct LockerNumberInputView: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject private var workoutStore: WorkoutStore
    @State private var lockerNumber: String = ""
    @FocusState private var isTextFieldFocused: Bool

    var body: some View {
        NavigationStack {
            ZStack {
                AppTheme.background
                    .ignoresSafeArea()

                VStack(spacing: 24) {
                    Spacer()

                    // Icon
                    Image(systemName: "lock.fill")
                        .font(.system(size: 60, weight: .semibold))
                        .foregroundStyle(
                            LinearGradient(
                                colors: [AppTheme.deepBlue, AppTheme.turquoiseBoost],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .padding(.bottom, 8)

                    // Title
                    Text("Deine Spintnummer")
                        .font(.system(size: 28, weight: .bold))
                        .foregroundStyle(.primary)

                    Text("Damit du sie nicht vergisst 😉")
                        .font(.system(size: 16, weight: .medium))
                        .foregroundStyle(.secondary)
                        .padding(.bottom, 16)

                    // Input Field
                    TextField("z.B. 42", text: $lockerNumber)
                        .font(.system(size: 48, weight: .bold))
                        .multilineTextAlignment(.center)
                        .keyboardType(.numberPad)
                        .focused($isTextFieldFocused)
                        .defaultFocus($isTextFieldFocused, true)
                        .padding()
                        .background(
                            RoundedRectangle(cornerRadius: 16)
                                .fill(Color(.systemGray6))
                        )
                        .frame(maxWidth: 200)
                        .onChange(of: isTextFieldFocused) { _, isFocused in
                            if isFocused && !lockerNumber.isEmpty {
                                // Auto-select all text when focused
                                DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
                                    UIApplication.shared.sendAction(#selector(UIResponder.selectAll(_:)), to: nil, from: nil, for: nil)
                                }
                            }
                        }

                    Spacer()

                    // Save Button
                    Button {
                        saveLockerNumber()
                    } label: {
                        Text("Speichern")
                            .font(.system(size: 18, weight: .bold))
                            .foregroundStyle(.white)
                            .frame(maxWidth: .infinity)
                            .padding()
                            .background(
                                RoundedRectangle(cornerRadius: 16)
                                    .fill(
                                        LinearGradient(
                                            colors: [AppTheme.mossGreen, AppTheme.turquoiseBoost],
                                            startPoint: .leading,
                                            endPoint: .trailing
                                        )
                                    )
                            )
                    }
                    .buttonStyle(.plain)
                    .padding(.horizontal, 32)
                    .padding(.bottom, 32)
                }
            }
            .navigationTitle("")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Abbrechen") {
                        dismiss()
                    }
                }
            }
            .onAppear {
                lockerNumber = workoutStore.userProfile.lockerNumber ?? ""
                // Aggressive focus - mehrfach versuchen
                isTextFieldFocused = true
                DispatchQueue.main.async {
                    isTextFieldFocused = true
                }
            }
        }
    }

    private func saveLockerNumber() {
        workoutStore.updateLockerNumber(lockerNumber.trimmingCharacters(in: .whitespacesAndNewlines))
        dismiss()
    }
}

